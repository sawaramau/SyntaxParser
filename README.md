# 構文解析器
* configクラス内でopdefineに従って演算子を定義するだけで使える構文解析器

# 設定方法
## 演算子定義
### 1項以上の引数をとる演算子の定義
* 配列形式で定義
```javascript
[1, "+", 1]
```
* 数値は項の数で文字列は演算子の識別記号です
* 例えば以下のように書き換える事で前置の加算演算子に変わります
```javascript
["+", 2]
```
* 囲い込むタイプの演算子も定義可能です
```javascript
["(", 1, ")"]
[1, "?", 1, ":", 1]
```
### 変数・リテラルの定義（0項の演算子）
* true/falseのような予約語は通常の演算子同様、配列形式で指定します
```javascript
["true"]
["false"]
```
* 変数や数値など可変な要素は関数形式で定義します
```javascript
(val) => {
    const hexreg = /^(0x[\d]+)$/;
    if (val.match(hexreg)) {
        return true;
    }
    return false;
}
(val) => {
    const varreg = /^[a-zA-Z_][\w]*$/;
    if (val.match(varreg)) {
        return true;
    }
    return false;
},
```
* 上記のように、先頭から一致している限りtrueを返すような関数を定義する事で変数・リテラルを定義可能です
* 変数の場合、演算方法の定義で別途名前解決の方法を用意する必要があります
### 空白文字などの定義（式上で意味を持たない文字列）
* 定義自体はリテラルと同様に関数形式で定義します
* 演算方法を未定義とすることで、構文解析器は文脈として解釈しないようになります

* 配列による定義は関数による定義より優先されます
* 予約語は必ず配列で定義してください

## 演算方法の定義
* 定義した演算子に対して、演算方法を定義できます
```javascript
["+", 2]
["true"]
```
* 例えば、上記のような演算子定義に対して、以下のように演算を定義できます。
```javascript
// + 2
(args) => {
    return args[0].value + args[1].value;
}
// true
() => {
    return true;
}
```
* リテラルの場合
```javascript
// hex
(val) => {
    return parseInt(val, 16);
}
```

# その他の情報の付加
* 現状ではメタ情報を付加して解釈に利用するような事はできません
* （コード上にそれらしい内容を書いてる部分がありますが動きません）

